A. Joysticks 
有两个游戏棒，充电时电量每分钟+1%，不充电每分钟-2%， 只有一个充电线，给定初始电量，问最多能玩多久。
递归，记忆化，每次可以给A充电也可以给B充电。好像贪心地给电量少的棒充电也可以。

B. Beautiful Paintings
n个数，要求重新安排数列，使得A[i + 1] > A[i]的个数最多。
贪心解，数都存到set当中，每次如果能使A[i + 1] > A[i]，则取可能的值中最小的一个，如果不可能，放置最小的数在该位置上，可以证明其他的放法一定不会优于这种放法

C. Watchmen
给n个点<int,int>， 求这些点中x1 = x2 或者y1 = y2的pair(x,y)的个数(x < y)
遍历每个点，如果遇到和之前的x相同的，则加上之前在x位置上点的个数。同理于y。
如果x和y都与之前的某个点相同，则会加2次，所以减去之前的相同的点的个数

D. Image Preview
给定n个照片的方向(w/h)，看每个照片花费1秒，如果是w就要花额外b秒将他rotate 90度才能看，目前处在index 0的照片的位置，可以往左滑(到n - 1)，或者往右滑（到1），每次滑动花费a秒， 给定时间T，问T秒内最多看多少照片。
二分答案，对于可能的个数val，我们可以用O(n)时间去验证是否存在
给定val，我们可能的策略是左边看1个，右边看val - 1个，左边看2个，右边val - 2个，...，共val + 1种策略
对于每种策略，最优的解法一定是先看完左边再看右边或者先看完右边再看左边，取决于哪边的个数比较少。
我们可以预先计算l[i]表示看完左侧i个所需的时间，r[i]表示看完右侧[i]个所需的时间，这样可以O(1)时间计算每种策略所需的时间，如果存在时间 <= T的，则返回true

E. Table Compression
给一个m * n矩阵，根据其产生一个新的矩阵，新矩阵的元素必须是positive的，而且每一行，每一列的相对大小保持不变。使矩阵的最大值尽量小
先对所有矩阵元素排序，然后用row[m], col[n]记录当前行目前的最小值，初始为0，一边遍历一边更新，其大小必须大于等于max(row[i], col[j]) + 1, 对于一样的值，他们必须相同，因此用并查集将他们group到一起，并在相同值的最后一个统一再更新一次，因为这些值必须是一样的。

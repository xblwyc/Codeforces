数学场，感觉适合中国人

A：
给定n表示金钱，a表示塑料瓶子饮料的价钱，b表示玻璃瓶子饮料的价钱，c表示玻璃瓶子喝完以后可以卖回去的价钱，问最多能喝多少瓶饮料。
n <= 1e18
O(1)时间内可以解决，
首先如果a <= (b - c)的话，那么肯定是全部买塑料瓶子的了，答案是n / a
如果a > (b - c)，不能直接/(b - c)，因为会存在情况就是n < b，这时没法买玻璃瓶子。
所以讨论，如果n >= b,那么n - k1 * (b - c) 直到 n < b，可以 求出k1 = (n - b + 1) / (b - c)
剩余的为_n = n - k1 * (b - c), 此时全部用来买a，则答案是_n / a + k1

B:
字符串的朴素查找。。没什么说的

C：
有n*n个数，值从1到n^2，要安排到一个矩阵里，使第k列的值最大，且每一行递增，问如何安排
贪心算法，不过我还没有证明出来答案是对的...
策略就是使每一行的第K个数尽量大。
那么从第一行到第N行的前k-1列一定要填满最小的N*(k- 1)个数，第K列后面的(N - K)列则继续用于填较小的剩下的数，依次类推。
可能的证明方法是首先可以证明每一行的第K列的这个数不存在的比他值大的可能性了，如果我把第一行第K列换成一个较小的数，剩余的数又不可能比其他的大，那么总的答案一定不如目前这个

D：
十分麻烦的题目。。。
首先定义flip操作为讲一个数字倒转，比如130倒转为031，即31，456倒转为654
目前已知flip(a) + a的值为x， 问a是否存在。
x有1e5位
设x有d位，那么a可能为d位，也可能为d - 1位，要分开讨论。
以前者为例，以bool dp[i][j][k], j = 0,1, k = 0,1 表示已处理至x的前第i位和后第i位，j,k表示前面是否富裕1和后面是否贡献了1.
设val1 = x[i] + j * 10, val2 = x[n - 1 - i] - k, 如果val1 == val2， 则至dp[i + 1][0][0], 如果val1 = val2 + 1,至dp[i + 1][1][0]
如果val1 == val2 + 10, 跳至dp[i + 1][0][1], 如果val1 == val2 + 11的话跳至dp[i + 1][1][1]

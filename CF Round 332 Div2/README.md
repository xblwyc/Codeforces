A. Patrick and Shopping 
应用Floyd-Warshall的想法，先把每两点之间的最短距离更新了，然后最后的结果就是d1 + d2 + d3

B. Spongebob and Joke 
题很简单，题意很复杂的典型。。 
大意就是A是一个长度m的数组，值得范围[1,n]，F是长度n的数组，B也是长度n的数组，对于B有B(i) = F(A(i))，现在已知B,F，求A的解的情况。 
因为F中的值范围也是[1,n]，先建立一个数组将F中每个值对应的index记录一下，比如说如果F是[1,2,2]，那么record[1] = {0}, record[2] = {1,2},record[3] = {}. 然后遍历B，对于每个B值，找到其对应的index，如果数量超过一个，那么肯定有ambiguity，如果数量是0，那么不可能啦，如果数量是1，继续check下一个，复杂度O(n)

C. Day at the Beach 
这道题卡了挺久。。。但是真的不难 
题意大概是讲将一个unsorted array 分成几部分，如果将每部分sort以后总的array是sorted的话，那么这个分块就是合理的，问最大的合理的分块是多少。 
一开始我打算二分然后验证分块是否合理，最后发现思路和直接解是一样的。 
当前块的最小值一定大于前一块的最大值，基于此推导的话一定是大于前面的块的所有的数。那么当前块的最大值一定是大于之前的所有的数的，而且是小于后面的块的最小值。 
那么我们找可能的最大值就行，最大值的条件是大于之前所有的数，他覆盖的范围是直到后面的数的最小值大于它。 
所以用prefix[i]记录前i 个数的最大值，suffix[i]记录从i开始后面的数的最小值。找到一个数发现他是最大值以后就不断向后找，直到suffx[i] 大于这个最大值。不过我发现直接找prefix[i] <= suffix[i] 和之前的算法等价。

D. Spongebob and Squares 
感觉C,D应该换一下难度才对 
大意就是对于m*n的一个矩阵，里面包含的长度为1，2，3…min(m,n)的正方体矩阵个数为x个，现在已知x，求可能的m，n。 
纯数学问题，如果m，n已知，假设m < n, 那么x = m * n + (m - 1) * (n - 1) + (m - 2) * (n - 2) +… + 1 * (n - m + 1) 
设diff = n - m, 那么x = 1 * (diff + 1) + 2 * (diff + 2) + … + m * (diff + m) = diff * (m + 1) * m / 2 + (m + 1)(m + 2)(2m + 1) / 6 
因为 x <= 1e18，所以m最多等于1e6, 从1开始遍历m就行，如果存在合理的diff的值，则记录n = diff + m 
记着每次要insert pair(m,n)和pair(n,m) 
我用set存得，所以复杂度O(NlgN)， N = 1e6，不过应该优化到O(N)是可以的
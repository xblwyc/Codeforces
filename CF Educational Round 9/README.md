其实多打打educational round真的挺好的。。 复习了很多有用算法

A B C都很简单
D. Longest Subsequence
给定n个数和一个值m，求最大的subsequence， 使得这个sequence里的数最多而且这些数的LCM不大于m
m,n <= 1e6
首先我们假定最后的这个LCM值为k，那么k <= m， 遍历每一个数，如果k % arr[i] == 0， 他一定会对这个最后结果做出贡献，换句话说，每个数都能对他的值得整数倍做出贡献。
因为k <= m，所以我们可以记录一下每个k总共之前有多少个数能做出贡献，然后找最大的。
另外两个point：
1.当数组是{2,2,2}这种情况的时候，LCM = 2， 所以要从大往小遍历结果
2.复杂度是O(mlog(n)),因为最大的情况是我们有n个不同的数，那么复杂度就是m / 1 + m / 2 + m / 3 + ... m / n， (1 + 1/2 + 1/3 + ... + 1/n ~= log(n))
在处理前要预先把重复的数聚合查count

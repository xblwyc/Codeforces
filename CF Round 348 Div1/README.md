A - Little Artem and Matrix
比较简单，初始化矩阵每个点的值为其位置的pair，有对应的操作移动相应的数组就可以，复杂度O(n*q)，在可以接受的范围内

B - Little Artem and Dance
这道题因为cin/cout的问题TLE了，很坑。
题意就是给定一个数组，初始为1,2,3,4...，然后有两种操作，左移x位或者右移x位，或者两两交换。
首先考虑如何处理两两交换，我们用两个数组，一个存奇数位置的值，一个存偶数位置的值，初始即为{1，3，5，7...}和{2,4,6,8...}。每次第二种操作就相当于交换这两个数组，所以用一个变量标记一下当前处于奇数位置的数组，每次异或即可。
对于每次的移动，如果x是偶数，那么就是偶数数组和奇数数组都移动x/2的位置即可。如果x是奇数，那么当前处于奇数位置的数组移动1，此时奇数位置的数组会被交换，然后再按照x是偶数处理即可。

D - Little Artem and Time Machine
大意就是有3种操作，第一种是在某个时间点插入值x，第二个是在某个时间点删除值x，第三个是在某个时间点查询x出现的次数。
我自己是用treap做的，因为总共操作数是小于1e5的所以对值x离散化之后，对每个值记录一下插入的时间点和删除的时间点。那么第三个操作就是查找小于等于该时间点的操作1和操作2个个数的差，如果该值存在在treap中，就查找这个值并求出其左子树和该node上总共count的个数，注意处理重复的情况。如果不存在的话，根据情况讨论。
我看大神们是用BIT做的，代码简单，简直被完爆。思路如下：
考虑如果空间足够大，那么我们对每个值都可以建立一个BIT，然后1操作就是在对应时间点+1， 2操作就是在对应时间点-1， 3操作就是求对应时间点前面的sum。
但是因为空间的原因，我们需要把所有值相同的操作group到一起，然后用bit处理该值，处理完以后再恢复（1操作时间点-1， 2操作时间点+1），再对下一个group进行处理。
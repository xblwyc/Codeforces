由于失误葬送了进到DIV1的机会。。心痛

B：Print Check
大意就是有m*n的一块板，k次操作，每次操作给一行或者一列涂某种颜色，让print最后的板
m,n<=5*1e3
n*m <= 1e5
k <=1e5
朴素算法是 O(k*max(m,n))，限时1s，还是有点危险的
记录k次操作，从后往前来，因为后面涂了颜色以后是不会被之前的覆盖的，每次涂遇到不是初始状态的就跳过，同时记录下已经涂过的行和列，遇到重复的直接跳过

C: Report
题意是有一个长度为n的原始数列， 进行m此操作，每次操作将前b[i]个数进行递增排序或者递减排序，求最后操作后的数列
m,n <= 2* 1e5
一开始一直想用线段树什么的做，当时还以为C题不会都用到线段树了吧
存一下前k个操作，如果某次的范围b[i]是小于等于后面某个数的，那么这次操作可以直接被忽略。
由此我们可以得到一个处理后的序列，其b[i]是递减的，然后对于同类型的连续的操作，后面的也可以直接被跳过，因此可以得到一个处理范围递减，类型相间的一串操作。
画图分析一下就可以知道，对于某次操作，相当于从arr[b[i] - 1]位置开始，不断的根据操作类型从最小递增或者从最大递减填充现有pool里的数，这个pool就是前b[0]个数

D：Messenger
大坑啊= =又是overflow的锅
一个string s用n个的pair<int,char>来表示，比如<1,'a'>, <5,'b'>表示abbbbb
同时string p也是用同样的方法表示，m个，
问p 在s中match的次数
m,n<=2e5

KMP算法，我是上网现搜的模板
对每个字符串进行预处理，将相邻的同类型的pair合并，注意overflow!!
然后将m，n更新一下
然后考虑m = 1和m = 2两种特殊情况，
对于m = 1， 遍历s, 如果i位置和p的字符, 则res += max(0, (s[i].first - p[0].first + 1))
对于m = 2， 依旧遍历s，如果发现连续2个位置和p的字符相同且长度均大于等于，则res++;
对于 m>= 3情况，我们掐头去尾，然后用KMP算法算出中间m - 2个块的exactly match， 记录位置，对于每个位置再double check一下前面的字符是不是和p[0]相同且长度大于等于，最后的字符是不是和p[m - 1]相同且长度大于等于，如果是则res++